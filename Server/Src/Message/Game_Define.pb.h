// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Game_Define.proto

#ifndef PROTOBUF_Game_5fDefine_2eproto__INCLUDED
#define PROTOBUF_Game_5fDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Game_5fDefine_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
inline void InitDefaults() {
}
}  // namespace protobuf_Game_5fDefine_2eproto

enum EObjectType {
  OT_NONE = 0,
  OT_PLAYER = 1,
  OT_NPC = 2,
  OT_MONSTER = 3,
  OT_PET = 4,
  OT_MOUNT = 5,
  OT_MACHINE = 6,
  OT_PARTNER = 7,
  OT_SUMMON = 8,
  EObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EObjectType_IsValid(int value);
const EObjectType EObjectType_MIN = OT_NONE;
const EObjectType EObjectType_MAX = OT_SUMMON;
const int EObjectType_ARRAYSIZE = EObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EObjectType_descriptor();
inline const ::std::string& EObjectType_Name(EObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EObjectType_descriptor(), value);
}
inline bool EObjectType_Parse(
    const ::std::string& name, EObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EObjectType>(
    EObjectType_descriptor(), name, value);
}
enum EActionType {
  AT_NONE = 0,
  AT_IDLE = 1,
  AT_FIXBODY = 2,
  AT_WALK = 3,
  AT_RUN = 4,
  AT_FLY = 5,
  AT_SKILL = 6,
  AT_MINE = 7,
  AT_ROLL = 8,
  AT_JUMP = 9,
  AT_BORN = 10,
  AT_DANCE = 11,
  AT_DEAD = 12,
  AT_WOUND = 13,
  AT_BEATBACK = 14,
  AT_BEATDOWN = 15,
  AT_BEATFLY = 16,
  EActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EActionType_IsValid(int value);
const EActionType EActionType_MIN = AT_NONE;
const EActionType EActionType_MAX = AT_BEATFLY;
const int EActionType_ARRAYSIZE = EActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EActionType_descriptor();
inline const ::std::string& EActionType_Name(EActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EActionType_descriptor(), value);
}
inline bool EActionType_Parse(
    const ::std::string& name, EActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EActionType>(
    EActionType_descriptor(), name, value);
}
enum EActionStatue {
  AS_NONE = 0,
  AS_HURT = 1,
  AS_START = 2,
  AS_END = 268435455,
  EActionStatue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EActionStatue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EActionStatue_IsValid(int value);
const EActionStatue EActionStatue_MIN = AS_NONE;
const EActionStatue EActionStatue_MAX = AS_END;
const int EActionStatue_ARRAYSIZE = EActionStatue_MAX + 1;

const ::google::protobuf::EnumDescriptor* EActionStatue_descriptor();
inline const ::std::string& EActionStatue_Name(EActionStatue value) {
  return ::google::protobuf::internal::NameOfEnum(
    EActionStatue_descriptor(), value);
}
inline bool EActionStatue_Parse(
    const ::std::string& name, EActionStatue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EActionStatue>(
    EActionStatue_descriptor(), name, value);
}
enum ECopyType {
  CPT_NONE = 0,
  CPT_LOGIN = 1,
  CPT_SELROLE = 2,
  CPT_CITY = 3,
  CPT_MAIN = 4,
  CPT_WORLD = 5,
  CPT_END = 100,
  ECopyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ECopyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ECopyType_IsValid(int value);
const ECopyType ECopyType_MIN = CPT_NONE;
const ECopyType ECopyType_MAX = CPT_END;
const int ECopyType_ARRAYSIZE = ECopyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECopyType_descriptor();
inline const ::std::string& ECopyType_Name(ECopyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECopyType_descriptor(), value);
}
inline bool ECopyType_Parse(
    const ::std::string& name, ECopyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECopyType>(
    ECopyType_descriptor(), name, value);
}
enum EObjectStatus {
  EOS_NONE = 0,
  EOS_DEAD = 1,
  EOS_NOT_MOVE = 2,
  EOS_NOT_CAST = 3,
  EOS_NOT_BEHURT = 4,
  EOS_NOT_BECONTROL = 5,
  EOS_STEALTH = 6,
  EOS_BLIND = 7,
  EObjectStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EObjectStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EObjectStatus_IsValid(int value);
const EObjectStatus EObjectStatus_MIN = EOS_NONE;
const EObjectStatus EObjectStatus_MAX = EOS_BLIND;
const int EObjectStatus_ARRAYSIZE = EObjectStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* EObjectStatus_descriptor();
inline const ::std::string& EObjectStatus_Name(EObjectStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    EObjectStatus_descriptor(), value);
}
inline bool EObjectStatus_Parse(
    const ::std::string& name, EObjectStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EObjectStatus>(
    EObjectStatus_descriptor(), name, value);
}
enum EItemType {
  EIT_NONE = 0,
  EIT_MONEY = 1,
  EIT_ACTION = 2,
  EIT_ITEM = 3,
  EIT_EQUIP = 4,
  EIT_GEM = 5,
  EIT_RELICS = 6,
  EIT_MOUNT = 7,
  EIT_PET = 8,
  EIT_PARTNER = 9,
  EIT_FASHION = 10,
  EIT_BOX = 11,
  EIT_ACTBOX = 12,
  EIT_CHIP = 13,
  EIT_RUNE = 14,
  EIT_DRUG = 15,
  EItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EItemType_IsValid(int value);
const EItemType EItemType_MIN = EIT_NONE;
const EItemType EItemType_MAX = EIT_DRUG;
const int EItemType_ARRAYSIZE = EItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EItemType_descriptor();
inline const ::std::string& EItemType_Name(EItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EItemType_descriptor(), value);
}
inline bool EItemType_Parse(
    const ::std::string& name, EItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EItemType>(
    EItemType_descriptor(), name, value);
}
enum EBagType {
  EBT_NONE = 0,
  EBT_ITEM = 1,
  EBT_GEM = 2,
  EBT_FASHION = 3,
  EBT_CHIP = 4,
  EBT_RUNE = 5,
  EBT_TASK = 6,
  EBT_SOUL = 7,
  EBT_CARD = 8,
  EBagType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EBagType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EBagType_IsValid(int value);
const EBagType EBagType_MIN = EBT_NONE;
const EBagType EBagType_MAX = EBT_CARD;
const int EBagType_ARRAYSIZE = EBagType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBagType_descriptor();
inline const ::std::string& EBagType_Name(EBagType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBagType_descriptor(), value);
}
inline bool EBagType_Parse(
    const ::std::string& name, EBagType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBagType>(
    EBagType_descriptor(), name, value);
}
enum EFunctionType {
  FUNC_BEGIN_ID = 0,
  FUNC_END_ID = 150,
  EFunctionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EFunctionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EFunctionType_IsValid(int value);
const EFunctionType EFunctionType_MIN = FUNC_BEGIN_ID;
const EFunctionType EFunctionType_MAX = FUNC_END_ID;
const int EFunctionType_ARRAYSIZE = EFunctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFunctionType_descriptor();
inline const ::std::string& EFunctionType_Name(EFunctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFunctionType_descriptor(), value);
}
inline bool EFunctionType_Parse(
    const ::std::string& name, EFunctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFunctionType>(
    EFunctionType_descriptor(), name, value);
}
enum EAttrID {
  EA_HP = 0,
  EA_MP = 1,
  EA_HP_MAX = 2,
  EA_MP_MAX = 3,
  EA_SPEED = 4,
  EA_ATTACK = 5,
  EA_ELEMENT = 6,
  EA_MAGIC_DEF = 7,
  EA_PHYSIC_DEF = 8,
  EA_HIT_RATE = 9,
  EA_DODGE = 10,
  EA_MORE_HURT = 11,
  EA_LESS_HURT = 12,
  EA_CRIT_HIT = 13,
  EA_CRIT_DEF = 14,
  EA_CRIT_HURT = 15,
  EA_ATTR_NUM = 16,
  EAttrID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EAttrID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EAttrID_IsValid(int value);
const EAttrID EAttrID_MIN = EA_HP;
const EAttrID EAttrID_MAX = EA_ATTR_NUM;
const int EAttrID_ARRAYSIZE = EAttrID_MAX + 1;

const ::google::protobuf::EnumDescriptor* EAttrID_descriptor();
inline const ::std::string& EAttrID_Name(EAttrID value) {
  return ::google::protobuf::internal::NameOfEnum(
    EAttrID_descriptor(), value);
}
inline bool EAttrID_Parse(
    const ::std::string& name, EAttrID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EAttrID>(
    EAttrID_descriptor(), name, value);
}
enum EShip {
  ES_NEUTRAL = 0,
  ES_FRIEND = 1,
  ES_ENEMY = 2,
  EShip_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EShip_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EShip_IsValid(int value);
const EShip EShip_MIN = ES_NEUTRAL;
const EShip EShip_MAX = ES_ENEMY;
const int EShip_ARRAYSIZE = EShip_MAX + 1;

const ::google::protobuf::EnumDescriptor* EShip_descriptor();
inline const ::std::string& EShip_Name(EShip value) {
  return ::google::protobuf::internal::NameOfEnum(
    EShip_descriptor(), value);
}
inline bool EShip_Parse(
    const ::std::string& name, EShip* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EShip>(
    EShip_descriptor(), name, value);
}
enum EHitShipType {
  EHST_ALL = 0,
  EHST_FRIEND = 1,
  EHST_ENEMY = 2,
  EHitShipType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EHitShipType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EHitShipType_IsValid(int value);
const EHitShipType EHitShipType_MIN = EHST_ALL;
const EHitShipType EHitShipType_MAX = EHST_ENEMY;
const int EHitShipType_ARRAYSIZE = EHitShipType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHitShipType_descriptor();
inline const ::std::string& EHitShipType_Name(EHitShipType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHitShipType_descriptor(), value);
}
inline bool EHitShipType_Parse(
    const ::std::string& name, EHitShipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHitShipType>(
    EHitShipType_descriptor(), name, value);
}
enum EBuffType {
  BFT_NONE = 0,
  EBuffType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EBuffType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EBuffType_IsValid(int value);
const EBuffType EBuffType_MIN = BFT_NONE;
const EBuffType EBuffType_MAX = BFT_NONE;
const int EBuffType_ARRAYSIZE = EBuffType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffType_descriptor();
inline const ::std::string& EBuffType_Name(EBuffType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffType_descriptor(), value);
}
inline bool EBuffType_Parse(
    const ::std::string& name, EBuffType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffType>(
    EBuffType_descriptor(), name, value);
}
enum EChatChannel {
  CHL_NONE = 0,
  CHL_WORLD = 1,
  CHL_PRIVATE = 2,
  CHL_GUILD = 3,
  CHL_GM = 4,
  EChatChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EChatChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EChatChannel_IsValid(int value);
const EChatChannel EChatChannel_MIN = CHL_NONE;
const EChatChannel EChatChannel_MAX = CHL_GM;
const int EChatChannel_ARRAYSIZE = EChatChannel_MAX + 1;

const ::google::protobuf::EnumDescriptor* EChatChannel_descriptor();
inline const ::std::string& EChatChannel_Name(EChatChannel value) {
  return ::google::protobuf::internal::NameOfEnum(
    EChatChannel_descriptor(), value);
}
inline bool EChatChannel_Parse(
    const ::std::string& name, EChatChannel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EChatChannel>(
    EChatChannel_descriptor(), name, value);
}
enum EEquipPos {
  EEP_NONE = 0,
  EEP_HELMET = 1,
  EEP_NECKLACE = 2,
  EEP_ARMOR = 3,
  EEP_SHOES = 4,
  EEP_WRIST = 5,
  EEP_RING = 6,
  EEP_TALISMAN = 7,
  EEP_WEAPON = 8,
  EEquipPos_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EEquipPos_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EEquipPos_IsValid(int value);
const EEquipPos EEquipPos_MIN = EEP_NONE;
const EEquipPos EEquipPos_MAX = EEP_WEAPON;
const int EEquipPos_ARRAYSIZE = EEquipPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEquipPos_descriptor();
inline const ::std::string& EEquipPos_Name(EEquipPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEquipPos_descriptor(), value);
}
inline bool EEquipPos_Parse(
    const ::std::string& name, EEquipPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEquipPos>(
    EEquipPos_descriptor(), name, value);
}
enum ETaskStatus {
  ETS_INIT = 0,
  ETS_ACCEPT = 1,
  ETS_FINISH = 2,
  ETS_COMMIT = 3,
  ETaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ETaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ETaskStatus_IsValid(int value);
const ETaskStatus ETaskStatus_MIN = ETS_INIT;
const ETaskStatus ETaskStatus_MAX = ETS_COMMIT;
const int ETaskStatus_ARRAYSIZE = ETaskStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETaskStatus_descriptor();
inline const ::std::string& ETaskStatus_Name(ETaskStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETaskStatus_descriptor(), value);
}
inline bool ETaskStatus_Parse(
    const ::std::string& name, ETaskStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETaskStatus>(
    ETaskStatus_descriptor(), name, value);
}
enum ECopyResult {
  ECR_NONE = 0,
  ECR_WIN = 1,
  ECR_LOST = 2,
  ECR_DRAW = 3,
  ECopyResult_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ECopyResult_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ECopyResult_IsValid(int value);
const ECopyResult ECopyResult_MIN = ECR_NONE;
const ECopyResult ECopyResult_MAX = ECR_DRAW;
const int ECopyResult_ARRAYSIZE = ECopyResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECopyResult_descriptor();
inline const ::std::string& ECopyResult_Name(ECopyResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECopyResult_descriptor(), value);
}
inline bool ECopyResult_Parse(
    const ::std::string& name, ECopyResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECopyResult>(
    ECopyResult_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::EObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EObjectType>() {
  return ::EObjectType_descriptor();
}
template <> struct is_proto_enum< ::EActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EActionType>() {
  return ::EActionType_descriptor();
}
template <> struct is_proto_enum< ::EActionStatue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EActionStatue>() {
  return ::EActionStatue_descriptor();
}
template <> struct is_proto_enum< ::ECopyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECopyType>() {
  return ::ECopyType_descriptor();
}
template <> struct is_proto_enum< ::EObjectStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EObjectStatus>() {
  return ::EObjectStatus_descriptor();
}
template <> struct is_proto_enum< ::EItemType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EItemType>() {
  return ::EItemType_descriptor();
}
template <> struct is_proto_enum< ::EBagType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBagType>() {
  return ::EBagType_descriptor();
}
template <> struct is_proto_enum< ::EFunctionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EFunctionType>() {
  return ::EFunctionType_descriptor();
}
template <> struct is_proto_enum< ::EAttrID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAttrID>() {
  return ::EAttrID_descriptor();
}
template <> struct is_proto_enum< ::EShip> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EShip>() {
  return ::EShip_descriptor();
}
template <> struct is_proto_enum< ::EHitShipType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EHitShipType>() {
  return ::EHitShipType_descriptor();
}
template <> struct is_proto_enum< ::EBuffType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBuffType>() {
  return ::EBuffType_descriptor();
}
template <> struct is_proto_enum< ::EChatChannel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EChatChannel>() {
  return ::EChatChannel_descriptor();
}
template <> struct is_proto_enum< ::EEquipPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EEquipPos>() {
  return ::EEquipPos_descriptor();
}
template <> struct is_proto_enum< ::ETaskStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETaskStatus>() {
  return ::ETaskStatus_descriptor();
}
template <> struct is_proto_enum< ::ECopyResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECopyResult>() {
  return ::ECopyResult_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Game_5fDefine_2eproto__INCLUDED
